## const



## static



## volatile

volatile的意思是 “易变的”，应该解释为“<span style="color:red;">直接存取原始内存地址</span> "比较合适。“易变”是因为外在因素引起的，比如多线程，中断等等。volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）

2）作用

- 防止变量被编译器优化

3）例子

```c
int main(void) {    
    volatile int i;
    int j;
    i = 1; //1 不被优化
    i = 2; //2 不被优化
    i = 3; //3 不被优化
    j = 1; //4 被优化
    j = 2; //5 被优化    
    j = 3; //6 j = 3 
}
```



```c
//单片机延时函数
void delay()
{
  int i = 0x1000000;
    while(i--);  
}
//单片机延时函数
void delay()
{
    volatile int i = 0x1000000; //防止编译器优化变量
    while(i--);
}
```



## auto 与 register

<a name="autoKeyWorld"> </a>

1)auto自动化变量(内存变量),定义变量时该关键字可以省略不写

```c
int a=10;//其实完整写法是 auto int a =10;//一般auto可以默认不写
```



比如：int a ---->其实全称应该是 signed int a ;//一般signed可以默认不写

2）register寄存器变量

调用频繁的变量可以定义成一个寄存器变量

```c
register int a = 10;// 变量在定义的时候会分配寄存器存储
&a 是错误的
```

注意：

- 定义寄存器变量不一定成功（主要看编译器）,如果不成功会自动定义成自动化变量
- 寄存器变量没有内存地址，所以不能取地址 &a

总结：变量从存储位置来说一般分为两种：存储在内存地址的自动化变量和存储在寄存器的寄存器变量。



## typedef 

1、概念

​	typedef 用来声明一个新类型

2、作用

给一个已经定义了的类型取一个新的名字，使新的名字更能表示它的含义。

```c
typedef  int  size_t;
void *malloc(size_t size);
```



3、给结构体取别名

```c
typedef struct node{
    int data;
}Node_t,*pNode_t;//表示给struct node结构体变量取一个别名Node_t,表示给struct node结构体指针变量取一个别名pNode_t
struct node{
    int data;
}Node_t,*pNode_t; //如果没有使用typedef关键字修饰，此时Node_t是该结构体的变量，pNode_t是该结构体的指针变量
```



4、给数组取新名字

```c
typedef int array[10];//新的类型为array,代表int[10];
array a;//定义一个数组a，它有10个元素，每个元素为int类型。
```



5、给函数指针取新名字

```c
int (*p)(int,char);//定义一个函数指针变量p
typedef int (*pfunc)(int,char);//声明一个新类型pfunc，该类型与p一样
```

