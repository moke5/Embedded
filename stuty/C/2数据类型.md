## 程序

新建文件后缀.c

```c
#include<stdio.h>

int main(int argc, char const *argv[])
{
    // 向终端输出一串字符
    printf("Hello World!\n");
    return 0;
}
```



### 程序分析

#### 头文件

```c
#include<stdio.h>
```

1. c语言程序中，任何符号（包括变量和函数）的使用，都是需要声明在使用的。
2. 如果程序用到了系统的库函数，那么就需要包含相应的头文件来进行声明。
3. 因为printf是在头文件 `stdio.h`中，因此在此程序中需要包含此头文件



**声明**

- 概念：对源文件外定义的某个符号进行描述的过程
- 作用：经过声明的符号，编译器才能正确识别和编译，否则编译器不认识，无法判定语法错误



#### 主函数

1. 主函数是必须有的，每一个c语言程序都有main函数，哪怕是空。
2. 主函数名是固定的，叫main，这个函数名不可以作他用。
3. 主函数是程序的入口，也就是程序开始的地方。
4. 主函数分解：

```c
// int ：返回值类型，代表主函数最终的执行结果是一个整数型数据
// main：main是函数名，名字唯一
// 		 void是函数参数列表，可以省略
int main(void)
{
    
}
```



- Linux环境下，主函数main根据程序最终是否需要接收外部命令行参数，有两个版本

```c
// 不接收外部命令行参数的版本
int main()
{
    
}
// 接收外部命令行参数的版本
int main(int argc, char *argv[])
{
    
}
```



#### printf

c语言被称为是一种面向过程的模块化语言，所谓模块，指的是一个个功能明确、各司其职的封装函数，她们就像一块块积木，被合理有机地拼搭起来，形成复杂、健壮的程序。

在这之中，系统标准C库提供了非常多”模块“，printf就是其中之一，它的功能是；向终端输出一段指定格式的数据。

```c
printf("Hello World!");
```



##### 格式输出空字符

- 概念：printf函数被称为格式化IO函数，因为它是按照指定的格式来操作数据的

```c
// 格式化输出函数
printf(); 

// 根据需要输出不同格式的数据
printf("%d\n", 100);          // 输出1个整数
printf("%d, %d\n", 100, 200); // 输出2个整数

printf("%f\n", 3.14);         // 输出浮点数
printf("%c\n", 'x');          // 输出字符
printf("%s\n", "abcd");       // 输出字符串

printf("a=%d, %s\n", "abcd"); // 输出字符串
```



- 语法点：
  - 类似%d、%f被称为格式控制符
  - 一个格式控制符，对应一个数据
  - '\n'是一个字符，表示回车符，详细ASCII码

- 格式控制符

1. 十进制整数：%d
2. 八进制整数：%o
3. 十六进制整数：%x
4. 字符：%c
5. 字符串：%s
6. 单精度浮点数：%f
7. 双精度浮点数：%lf
8. 长双精度浮点数：%Lf
9. 地址：%p
10. h表示一般：%hd：表示int字节的一半就是short，%hhd表示char

### man

>查询指定系统函数头文件方法
- ubuntu
- 查询printf函数所在哪一本手册中
```bash
man -f printf
```
- man手册的手册一是linux终端命令
man 3 printf

### return

c语言中的关键字 `return`的含义就是结束一个函数，并返回某个数据（如有）。而具体到 `main`函数中时，由于main函数结束也意味着整个程序结束，

一般而言程序正常退出时，main函数返回值是0；当程序异常退出时，返回值非0

注意：main函数的返回值是给上一级进程的，因此理论上在当前的单进程程序中，main函数的返回值是什么都无所谓，因为根本没有去使用这个返回值，除非在多进程程序中，进程间才需要使用main函数返回值来传递信息。



## 编译程序

将c语言程序转化称为计算机能够识别的可执行程序（二进制文件）

### 编译

```bash
使用 gcc 编译器	 编译 c程序
china@ubuntu:~$ gcc hello.c  -o hello
china@ubuntu:~$ gcc hello.c   --会默认生成  可执行程序 a.out
./a.out    
```

### 执行

```bash
./a.out
./hello
```



### 查看文件属性

```bash
china@ubuntu:~$ file hello
hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=2500b0e3243b8052a5cdb06925e15447ea54c4ba, not stripped

x86-64---》该程序可以运行在 x86-64平台
ELF ---》二进制文件格式
```



### 编译阶段

检查语法

编译之后的表现：

1）编译通过

​	编译之后没有任何提示，说明 编译完美通过，生成一个可执行程序。

2）编译警告

​	编译之后会出现warning提示，还是可以生成一个可执行程序。比如头文件 没写

​	警告虽然不代表出错，有些警告可以忽略，但是有些警告不能忽略

3）编译出错

​	语法出错，会有一个明显的提示error，根据提示出错的信息找到问题所在



# 数据类型

我们编写程序的目的是让计算机能够帮助我们去处理数据。计算机要处理的数据（诸如数字、字符串、文字、符号、图形、音频、视频等）是以二进制的形式存放在内存中的。而且在程序中数据是有类型区分，通常分为整型、浮点型、字符串等等。<span style="color:red;">数据类型其实是固定大小内存的别名。并且描述了一个变量存放什么类型的数据。</span>



### 内存存储容量单位

字节（byte B）；计算存储容量的一种单位

比特位(bit)：二进制数   0     1

1个字节 =  8位 二进制

1个千字节（KB） = 1024字节

1M = 1024KB

1G  = 1024M

1T  = 1024G



### 数据类型分类和计算方法

```c
int  (整型)                		4
double（双精度浮点型 ）             8
float  （单精度浮点型）             4 
char  （单个字符  'a'  'b'）       1
short   int     (短整型)          2
long   （long int）长整型          4(32位编译器)      8（64位编译器）
long long     （long  long int）（长长整型）        8
bool   _Bool  （布尔类型  真  ture  假 false ）    1
```

注意：

```c
printf("true  size:%d\n",sizeof(true));     占 4个字节
printf("false  size:%d\n",sizeof(false));   占 4个字节 
```

ps:使用mingw时sizeof(true/false)是占一个字节

计算 某个数据类型或者变量 所占的字节数 ----》sizeof( 某个数据类型或者变量名)

总结：

​	1）数据类型在内存中所占的字节数跟C语言的编译系统有关

​	2）计算 某个数据类型 所占的字节数可以用sizeof

 	3)  布尔类型  要添加  #include



## 整形

```c
int a = 123; // 定义了一个专门用来存储整形变量a的地方
```

ps：

1. int 的本意是 integer，即整数的意思
2. int a 代表在内存中开辟一块小区域，称为 a，用来存放整数，a 一般被称为变量。
3. 变量 a 所占内存大小，在不同的系统中是不一样的，64位系统典型的大小是4个字节。
4. 变量 a 有固定的大小，因此也有取值范围，典型的范围是：-2147483648到2147483647

### 整型修饰符

- - short：用来缩短整型变量的尺寸，减少取值范围并节省内存，称为短整型
  - long：用来增长整型变量的尺寸，增大取值范围并占用更多内存，称为长整型
  - long long：用来增长整型变量的尺寸，增大取值范围并占用更多内存，称为长长整型
  - unsigned：用来去除整型变量的符号位，使得整型变量只能表达非负整数



```c
short int a; // 短整型
long int b;  // 长整型
long long int c; // 长长整型

unsigned int e;  // 无符号整型

unsigned short int f; // 无符号短整型
unsigned long int g;  // 无符号长整型
unsigned long long int h; // 无符号长长整型
```



使用整形修饰符后，关键字int可以被省略：

```c
short a; // 短整型
long b;  // 长整型
long long c; // 长长整型

unsigned e;  // 无符号整型

unsigned short f; // 无符号短整型
unsigned long g;  // 无符号长整型
unsigned long long h; // 无符号长长整型
```



### 符号位

- - 有符号的整型数据，首位为符号位，0表示正数，1表示负数。
  - 无符号的整形数据，没有符号位。

```c
有符号数     (signed )   int  a = -100   int   a = 100;  
-->存储到内存中，最高位 表示符号位  1表示负数  0表示正数
无符号数     unsigned    int  a = 100;  
```



### 数据类型的值域范围

- 溢出：

- - 超过数据所能表达的范围，称为溢出，就像汽车里程表，最大值和最小值是相邻的

unsigned  char   0 ~ 255

signed char       -128 ~+127	

正数： +0 +1 ....+127

负数：  -0 -1 ......-127

由于 +0 和 -0 重复了， -0 表示 -128

unsigned  short    0~65535（2^16-1）

unsigned  int        0 ~ 4294967295（2^32-1）



```c
unsigned  char a = 257;
char    b = 129; 

printf("a:%hhu\n",a); 
 //%u --->unsigned int     %hu   half unsigned  int     %hhu   half  half unsigned  int
printf("b:%hhd\n",b);
```



```c
#include<stdio.h>
#include<stdbool.h>

int main()
{
    unsigned  char a = 257;  //a  = 
    char    b = 129;   // b = 
    //printf 函数  是  将指定格式的数据输出到屏幕终端
    printf("a:%u\n",a); //a == 1
    printf("b:%d\n",b); //b:-127
    
    return 0;
}
```



### 编码形式

- - 原码：正数直接使用二进制来表达，比如a=100，在内存中是 00…001100100
  - 反码：原码取反
  - 补码：负数用绝对值取反加一来表达，比如a=-3，在内存中是11…1111111101
  - 注意负数的补码在取反加一的时候，符号位是不动的



## 整数存储方式

整数为何以补码方式存储

加法和减法是计算机中最基本的运算，计算机时时刻刻都离不开它们，所以它们由硬件直接支持。为了提高加减法的运算效率，硬件电路要设计得尽量简单。

对于有符号数，内存要区分符号位和数值位，对于人脑来说，很容易辨别，但是对于计算机来说，就要设计专门的电路，这无疑增加了硬件的复杂性，增加了计算的时间。要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，这样硬件电路就变得简单了。



加法和减法也可以合并为一种运算，就是加法运算，因为减去一个数相当于加上这个数的相反数，例如，5 - 3 等价于 5 + (-3)，10 - (-9) 等价于 10 + 9。

相反数是指数值相同，符号不同的两个数，例如，10 和 -10 就是一对相反数，-98 和 98 也是一对相反数。

如果能够实现上面的两个目标，那么只要设计一种简单的、不用区分符号位和数值位的加法电路，就能同时实现加法和减法运算，并且非常高效。实际上，这两个目标都已经实现了，真正的计算机硬件电路就是如此简单。

然而，简化硬件电路是有代价的，这个代价就是有符号数在存储和读取时都要进行转化。那么，这个转换过程究竟是怎样的呢？接下来我们就详细地讲解一下。**在内存当中，最终存储的是变量的补码**



### 原码

将一个整数转换成二进制形式，就是其原码。例如short a = 6;，a 的原码就是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的原码就是1000 0000 0001 0010。

通俗的理解，原码就是一个整数本来的二进制形式。

正数与负数的原码区别在于符号位（二进制最高位表示，0：正数，1：负数）



### 反码

谈到反码，正数和负数要区别对待，因为它们的反码不一样。

对于正数，它的反码就是其原码（原码和反码相同）；
负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。
例如short a = 6;，a 的原码和反码都是0000 0000 0000 0110；
更改 a 的值a = -18;，此时 a 的反码是1111 1110 1101。

short a = -100的反码：1111 1111 1001 1011



### 补码

正数和负数的补码也不一样，也要区别对待。

对于正数，它的补码就是其原码（原码、反码、补码都相同）；
负数的补码是其反码加 1。例如short a = 6;，a 的原码、反码、补码都是0000 0000 0000 0110；
更改 a 的值a = -18;，此时 a 的补码是1111 1111 1110 1110 = 1111 1111 1110 1101（负数反码）+ 1。

可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。

原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。



### 转换过程

6 和 -18 从原码到补码的转换过程

![1numberstoragebinary1](.\img\1numberstoragebinary1.png)

<span style="color:red;">在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。</span>将补码转换为原码也很简单：先减去 1，再将数值位取反即可。



总结：

​	(1)当编译器以整型输出时(%d)，是以补码还原的方式来解读的。

​	(2)当CPU对数据进行运算时，直接以内存中存放的形式进行运算，即补码的形式

​	(3)  %u 打印的时候， 值域的范围： unsigned int   0-4294967295

​	(4)  %hhu 打印的时候， 值域的范围： unsigned char  0-255



练习

```c
unsigned char a = 255;
char b = 255;  
printf("%d %u\n",a,a); 
printf("%d %u\n",b,b); 
(2)
unsigned short a = -1; 
int b = a; 
printf("%d\n",a);
printf("%d\n",b);

(3)
unsigned char a = -1;  
unsigned int b = -1; 
printf("%d %u\n",a,b);
```



答案：

```c
1)unsigned char a = 255;  // 0 - 255
   char b = 255;   // -128 ~ +127
   printf("%d %u\n",a,a); // 255  255
   printf("%d %u\n",b,b); // -1   4294967295
    
                
(2)unsigned short a = -1; // 0-65535
   int b = a;  //65535
   printf("%d\n",a);// 65535
   printf("%d\n",b);// 65535

(3)unsigned char a = -1;  //0-255   a--->255
   unsigned int b = -1;  // 0- 4294967295
   printf("%d %u\n",a,b); //a == 255  b == 4294967295
```



## char类型

```c
字符常量     'a'      'b'    'w'    '1'
char   value1 = 'a';   
char   value2 = 'b'; 
```



### ASCII码

概念：char数据实际上是在内存存放的是一个小于255的编号(无符号整数)用来表示字符，这个编号叫做ASCII码。

如何查看  ascii 码？？

​	man ascii

```c
char a = 'A'   比如 'A'----》存储到内存中是65
```

注意：如果是 sizeof('a')  ,那么结果就是4 ，因为在使用sizeof运算的时候，字符数据 就会转换为ascii码的形式，所以不能使用这种方法计算单个字符的大小

必记：

0    表示空  \0
48  表示   字符0
65  表示   字符A
97  表示   字符a

\后面可以跟任何字符八进制或十六进制ascii码将其从ascii码转为文本字符

![1ASCII1](.\img\1ASCII1.png)

![1ASCII2](.\img\1ASCII2.png)



### 转义字符

概念：

所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加  '\' 来表示常见的那些不能显示的ASCII字符，如'\0','\t','\n'等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符的意思了。它告诉编译器需要用特殊的方式进行处理。

'\ddd' ddd表示1到3位八进制数，打印效果为该数字对应的ASCII字符

字符的表示有多种方法：

![1number](.\img\1charstorage1.png)

'a'        '\141'             '\x61'    

字符      '\八进制'      '\x十六进制'

```c
printf("%c\n",'\102');  --》B
```

请问：'\83'   是否正确？？？  错误 

'\xhh' hh表示1到2位十六进制数，打印效果为该数字对应的ASCII字符

```c
printf("%c\n",'\x42'); --》B
```

常见的转义字符：

```c
'\n'   换行
'\t'   横向跳格(Tab)
'\r'   回车，返回行首
'\\'   反斜杠   '\'
```

练习1: 以下哪些不是字符

"a"  'a'  '\t'   '\n'   '\033'                             '\0x10'  

练习2： '\41' 转换之后的字符是什么

答案：

练习1："a"  

练习2： '\41'  -->八进制  相当于  '\041'   ，打印出来是字符  !



## 浮点型

概念：用来表达实数(小数)的数据类型

分类：

- 单精度浮点型（float），在64位系统中典型尺寸是4字节，精确到小数点后6位
- 双精度浮点型（double），在64位系统中典型尺寸是8字节，精确到小数点后15~16位
- 长双精度浮点型（long double），典型尺寸是16字节

占用内存越多，能表达的精度越高

```c
float f1; // 单精度
double f2; // 双精度
long double f3; // 长双精度
```



用户有的时候需要处理小数，小数在C语言中也被称为浮点数，C语言中使用关键字float表示单精度浮点型，一般占4字节，同样C语言使用关键字double表示双精度浮点型，一般占8字节，其实C语言也提供 long double，一般占16字节。数据宽度越大，则数字精度越高。

C语言中一般浮点数有两种表示形式： 十进制形式  +  指数形式 ，两者的区别如下所示：

十进制形式：指的是数字必须以整数形式+小数形式组成，比如 10.0 、3.14 ......符合规则

指数形式	：一般数学上对于小数可以以10为底进行表示 比如3.14 * 10²，但是在使用英文半角输入法的时候没办法输入上底或者下底，所以C语言规定以字母e或者E来表示指数，并且要求字母e或者E的前面必须有数字，字母e或者E的后面必须为整数。 -3.14E-2  2E-3  0.3E4

所以：  E3  错误   因为E的前面有数据   比如说  3.14E3

​           3.1e5.6 错误  因为 E的后面必须是整数



## 进制表示

数据在表示形式上是采用十进制。十进制是人类最熟悉的数制，因为它与人类的计数习惯（十个手指）相吻合，适合日常计算和交流。

但是除了十进制之外，数据还可以使用二进制、八进制、十六进制去表示。不同的数制系统在不同的应用场景中各有优势，选择合适的数制可以提高工作效率和数据处理的效率。

二进制是计算机处理数据的基础，因为计算机的硬件由电子元件组成，这些元件的状态可以用二进制的0和1来表示，便于实现逻辑运算和数据存储。

八进制在某些特定领域（如早期计算机系统）有应用，因为早期计算机的字长（如6位、12位）是3的倍数，八进制可以方便地表示这些字长。

十六进制常用于表示二进制数据，因为它可以更简洁地表示大量二进制位，便于人类阅读和理解。例如，在内存地址、颜色编码等领域，十六进制提供了更直观的表示方式。



### 进制系统

#### 二进制

**二进制由 0 和 1 两个数字组成**，**使用时必须以**0b**或0B**（不区分大小写）开头，例如：

```c
//合法二进制
int a = 0b101;    //换算成十进制5
int b = -0b110010; //换算成十进制-50
int c = 0B100001;  //换算成十进制33

//不合法的二进制
int m = 101001;   //无前缀0b或0B，相当于十进制
int n = 0B401;    //4不是有效的二进制数字
```

**读者请注意，标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字**。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。

下面是实际测试的结果：

- Visual C++ 6.0 不支持。
- Visual Studio 2015 支持，但是 Visual Studio 2010 不支持；可以认为，高版本的 Visual Studio 支持二进制数字，低版本的 Visual Studio 不支持。
- GCC 4.8.2 支持，但是 GCC 3.4.5 不支持；可以认为，高版本的 GCC 支持二进制数字，低版本的 GCC 不支持。
- LLVM/Clang 支持（内嵌于 Mac OS 下的 Xcode 中）。
- window VScode支持



**运算法则：**逢二进一，借一当二

0B1101 -  0B0011 = 0B1010

0B1101 + 0B0011 = 0B10000



#### 八进制

八进制由 0~7 八个数字组成，**使用时必须以** **0** **开头**（注意是数字 0，不是字母 o），例如：

```c
//合法八进制
int a =  0105;    //换算成十进制69   0105  105
int b = -0101;    //换算成十进制-65
int c = 017777;  //换算成十进制8191

//不合法的八进制
int m = 256;     //无前缀0，相当于十进制
int n = 0810;    //8不是有效的八进制数字
```

**运算法则：**逢八进一，借一当八

```c
0720 - 0101 = 0617
0325 + 0316  = 0643
```



#### 十六进制

十六进制由数字 0~9、字母 A~F 或 a~f（ 不区分大小写  A == 10  B==11 C==12 D==13 E==14 F==15）组成，**使用时必须以** **0x** **或** **0X** **（不区分大小写）开头**，例如：

```c
//合法十六进制
int a =  0x2B;    //换算成十进制43
int b = -0xA0;    //换算成十进制160
int c = 0X70;     //换算成十进制112

//不合法的十六进制
int m = 5A;     //无前缀0X，是一个无效的数字
int n = 0x6H;    //H一个无效的十六进制数字
```



**运算法则：逢十六进一，借一当十六**

```c
0x71 - 0x2C  =  0x45
```

```c
0x88 + 0xA8 = 0x130
```



#### 十进制

十进制由 0~9 十个数字组成，没有任何前缀，和我们平时的书写格式一样，不再赘述



### 进制转换

#### 十进制转其他

短处法

方法为：十进制数除2取余法。（转八进制时为除8取余法；转十六进制时除16取余）

例如：把十进制数 150 转换为 二进制数：如下：

![1biary1](.\img\1biary1.png)

**独特转化方法：**

**权位值**

8192 4096 2048    1024	512	   256	128	   64	   32	  16	   8	  4	  2	 1 

独特转化方法：将数字进行拆解，必须按最近最大权位值拆解，将有数字的位进行置即可。

100 = 64 + 32 + 4

​	   64	   32	  16	   8	  4	  2	 1 

​           1       1     0      0     1      0      0

819  = 512 + 256 + 32 + 16 + 2 + 1 转化二进制：1 1 0 0 1 1 0 0 1 1

#### 二转十

权位值法

向十进制转时，将各位数按权展开，从右向左依次拿每位上的数乘以二（八 / 十六）的 0 1 2 ……次方，然后相加的和即是相应的十进制数。

```c
第4位                       第0位
1      0      1       1     0
对应的位为1，则权值2^第几位
0B10110 = 2^4+2^2+2^1=16+4+2 = 22
```

**独特二进制转化10进制方法：**

**权位值**

2048    1024	512	   256	128	   64	   32	  16	   8	  4	  2	 1 

独特转化方法：将对应的二进制权位值进行相加即可得对应的十进制数

 1  1  0  1  0 1 化成十进制：32+16+4+1 = 53

​	   32	  16	   8	  4	  2	 1 （权位值）

​        1        1       0        1      0     1



#### 二转八

方法为：每3位二进制数按权合成，然后相加得到1位八进制数。（注意事项，**每3位二进制转成八进制是从右到左开始转换，不足时补0**）。

![1binary2](.\img\1binary2.png)

1101001011010

第一步骤先分组：001 101 001 011 010  

第二步，按权值合成八进制：015132



#### 八转二

方法为：将八进制数的每一位通过除2取余法得到一个二进制数（也可以通过权值法），这个二进制数必须是3位，如果不够3 位，则最左补0。

值为：0226
![1binary3](.\img\1binary3.png)

0712 =0B111001010

0556=0B101101110



#### 二转十六

与二进制转八进制相似，每四位按权相加得到一个数，从最右开始，最后若不足4位则向最左边补0，然后得到十六进制数。

![1binary4](.\img\1binary4.png)

0B1011011011110

步骤一：先分组（4位为一组）： **000** **1  0110  1101 1110  = 0x1 6 D E**




#### 十六转二

方法为：将十六进制数的每一位通过除2取余法(也可以通过权值法)，得到二进制数，**每一位十六进制数得到的二进制数都应该是4位**，不足时在最左边补零。

![1binary5](.\img\1binary5.png)

0xDD8 =  0B   1101  1101 1000



#### 十六||八

方法为：借用一个中间进制，即先将十六进制（八进制）转换为二进制，然后再将二进制转换为八进制（十六进制）

0xA9F   = 1010 1001 1111 (二进制) =   101 010 011 111  (二进制) = 0 5 2 3 7

​                                分（二进制）                                      合（八进制）

0xE139A = 0B1110  0001  0011  1001 1010  =  011 100 001 001 110 011 010  = 03411632



### 进制总结

1）记住二进制与十进制权位值关系

512		256		128		64		32		16		8		4		2		1

1                 1             1             1              1              1              1             1               1             1

（2）进制之间转化要借助中间进制

十六进制转八进制借二进制， 十进制转八进制借用二进制，十六进制转十进制借二进制。



### 进制输出

C语言中常用的整数有 short、int 和 long 三种类型，通过 printf 函数，可以将它们以八进制、十进制和十六进制的形式输出。上节我们讲解了如何以十进制的形式输出，这节我们重点讲解如何以八进制和十六进制的形式输出，下表列出了不同类型的整数、以不同进制的形式输出时对应的格式控制符：

![1binary6](.\img\1binary6.png)

十六进制数字的表示用到了英文字母，有大小写之分，要在格式控制符中体现出来：

- %hx、%x 和 %lx 中的x小写，表明以小写字母的形式输出十六进制数；
- %hX、%X 和 %lX 中的X大写，表明以大写字母的形式输出十六进制数。



八进制数字和十进制数字不区分大小写，所以格式控制符都用小写形式。如果你比较叛逆，想使用大写形式，那么行为是未定义的，请你慎重：

- 有些编译器支持大写形式，只不过行为和小写形式一样；
- 有些编译器不支持大写形式，可能会报错，也可能会导致奇怪的输出。

注意，虽然部分编译器支持二进制数字的表示，但是却不能使用 printf 函数输出二进制，这一点比较遗憾。当然，通过转换函数可以将其它进制数字转换成二进制数字，并以字符串的形式存储，然后在 printf 函数中使用%s输出即可。考虑到读者的基础还不够，这里就先不讲这种方法了。



【实例】以不同进制的形式输出整数：

```c
#include <stdio.h>
int main()
{
    short a = 0b1010110;  //二进制数字
    int b = 02713;  //八进制数字
    long c = 0X1DAB83;  //十六进制数字
   
    printf("a=%ho, b=%o, c=%lo\n", a, b, c);  //以八进制形似输出
    printf("a=%hd, b=%d, c=%ld\n", a, b, c);  //以十进制形式输出
    printf("a=%hx, b=%x, c=%lx\n", a, b, c);  //以十六进制形式输出（字母小写）
    printf("a=%hX, b=%X, c=%lX\n", a, b, c);  //以十六进制形式输出（字母大写）
    return 0;
}
```



```c
a=126, b=2713, c=7325603
a=86, b=1483, c=1944451
a=56, b=5cb, c=1dab83
a=56, b=5CB, c=1DAB83
```



从这个例子可以发现，一个数字不管以何种进制来表示，都能够以任意进制的形式输出。数字在内存中始终以二进制的形式存储，其它进制的数字在存储前都必须转换为二进制形式；同理，一个数字在输出时要进行逆向的转换，也就是从二进制转换为其他进制。

**输出时加上前缀**

请读者注意观察上面的例子，会发现有一点不完美，如果只看输出结果：

- 对于八进制数字，它没法和十进制、十六进制区分，因为八进制、十进制和十六进制都包含 0~7 这几个数字。
- 对于十进制数字，它没法和十六进制区分，因为十六进制也包含 0~9 这几个数字。如果十进制数字中还不包含 8 和 9，那么也不能和八进制区分了。
- 对于十六进制数字，如果没有包含 a~f 或者 A~F，那么就无法和十进制区分，如果还不包含 8 和 9，那么也不能和八进制区分了。

区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上#即可输出前缀，例如 %#x、%#o、%#lX、%#ho 等，请看下面的代码：

```c
#include <stdio.h>
int main()
{
    short a = 0b1010110;  //二进制数字
    int b = 02713;  //八进制数字
    long c = 0X1DAB83;  //十六进制数字
   
    printf("a=%#ho, b=%#o, c=%#lo\n", a, b, c);  //以八进制形似输出
    printf("a=%hd, b=%d, c=%ld\n", a, b, c);  //以十进制形式输出
    printf("a=%#hx, b=%#x, c=%#lx\n", a, b, c);  //以十六进制形式输出（字母小写）
    printf("a=%#hX, b=%#X, c=%#lX\n", a, b, c);  //以十六进制形式输出（字母大写）
   
    return 0;
}
```



```c
a=0126, b=02713, c=07325603
a=86, b=1483, c=1944451
a=0x56, b=0x5cb, c=0x1dab83
a=0X56, b=0X5CB, c=0X1DAB83
```



十进制数字没有前缀，所以不用加#。如果你加上了，那么它的行为是未定义的，有的编译器支持十进制加#，只不过输出结果和没有加#一样，有的编译器不支持加#，可能会报错，也可能会导致奇怪的输出；但是，大部分编译器都能正常输出，不至于当成一种错误。



## 变量

常量：程序运行期间，其值不能被改变的量称为常量

```c
如:   1  2  3     3.14
 3 = 4;//error,3是一个常量，其值不能被改变
```



变量：

​	变量实质上是内存中一个具有特定属性的存储单元，它是用来存放数据的。

​	这个存储单元中的数据，就是变量的值，而这个值可以在程序运行期间可以被改变(赋值)

![1variable1](.\img\1variable1.png)

### 变量的定义

```c
数据类型    变量名;
int      value;
int      min,max;
```

注意：C语言标识符（函数名、变量）由字母、数字、下划线(_)组成，并且由字母或者下划线开头。而且标识符不能和C语言关键字、库函数同名，虽然标识符没有限制长度，但是尽量不要写太长。自定义的标识符最好有一定的含义，方便记忆和理解。



### 作用

申请该类型对应的内存空间，由变量名间接访问这片内存空间

4、变量的访问(读/写)

(1)从变量中取值(读),实际上是通过变量名找到相应的内存地址，从该地址对应的存储单元中读取数据。

​     这时变量一般在赋值符号(=)的右边，表示变量的值，我们称为右值。（变量的值称之为右值）

(2)给变量赋值(写),实际上通过变量名找到相应的内存地址，把数据写到该地址对应的存储单元中去，

​    覆盖掉原来的值，这时变量一般在赋值符号(=)的左边，表示变量的内存空间，我们称为左值。（变量的地址称之为左值）



### 赋值

```c
1、定义的时候初始化（给变量的第一次赋值，我们叫做初始化）
    int  a = 4;
2、先定义，后初始化
    int  a;     //里面是一个随机值
    a = 4;
```

变量的分类、变量的生命周期与作用域

局部变量

全局变量

1）定义位置

局部变量在函数体内定义  ---》运行到该函数的时候才给这个变量指定和申请内存空间

全局变量在函数体外定义----》在程序开始运行时，就给这个变量申请内存空间

2）优缺点

全局变量  ---》在所有的函数内部都可以访问  ---》内存空间直到程序结束才会释放

局部变量----》只能在函数内部使用    ----------》在栈空间申请，函数返回时，就会释放内存

----》提高程序运行效率，尽量避免使用全局变量

3）值

局部变量如果不赋值，那么结果是随机值

全局变量如果不赋值，那么结果就为0

结论：

1）可以在不同的函数中定义相同的变量名

2）全局变量作用域只能往下，不能往上

3）全局变量本文件中定义，在另一个文件中调用之前，先进行声明

​	extern int func_a;//声明这个变量是在别的文件中

ps:

可读可写
- 读操作，右值
- 写操作，左值

第一次赋值就是初始化。

