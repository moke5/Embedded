# 概念

## 定义

- 逻辑：一次性定义多个相同类型的变量，并存储到一片连续的内存中

ps:存储相同数据类型的集合被称为数组，作用将逻辑上一组（一系列）数据存储在一段连续的内存中。

```c
int a[5];
```



- 语法释义：
  - a 是数组名，即这片连续内存的名称
  - [5] 代表这片连续内存总共分成5个相等的格子，每个格子称为数组的元素
    - []
  
  在声明数组变量时表示的数组长度
  
  声明数组 sizeof取数组大小 &数组 这三种情况以外，其他情况表示描述数组首元素地址
  
  - int 代表每个元素的类型，可以是任意基本类型，也可以是组合类型，甚至可以是数组

![5array1png](.\img\5array1png.png)

## 数组初始化

在定义的时候赋值，称为初始化

```c
// 正常初始化
int a[5] = {100,200,300,400,500};

int a[5] = {100,200,300,400,500,600}; // 错误，越界了
int a[ ] = {100,200,300}; // OK，自动根据初始化列表分配数组元素个数
int a[5] = {100,200,300}; // OK，只初始化数组元素的一部分
```

![5array_memory1](.\img\5array_memory1.png)

<div align="center"> 
    <p>数组的真实存储</p>
</div>

对大型数组，有时还可以指定范围初始化，比如：

```c
// 将数组前500个元素初始化为 'x'
char big_array[1000] = {[0 ... 499]='x'};
```



```c
	// 数组中所有的元素数据类型都是一致的
    // 数组申请的内存是连续的。从低地址到高地址依次连续存放数组中的每个元素
    // 1. 数组只有在声明的时候支持整体赋值
    int arr1[5] = {2, 4, 6, 8, 10};

    // 2. 数组如果初始化,可以在声明时省略数组长度,此时数组的长度将由编译器隐式指定
    int arr3[] = {7, 8, 9, 10};

    // 3. 数组初始化可以部分赋值, 没有赋值的元素会自动赋值为0
    int arr4[7] = {1, 2, 3};
    // 3.1 借助上面特性,可以实现数组清零
    int arr6[5] = {0};

    // 4. 数组若没有初始化,不能省略数组长度,其内部元素的值为随机数
    int arr2[5];

    // 5. 数组整体赋值,值的长度不能超过数组的长度,虽然编译不会报错但是会产生非常严重的问题运行时产生"段错误"非法访问内存
    // int arr5[3] = {1, 2, 3, 4, 5, 6, 7}; 

    // 数组声明完毕只能通过下标(索引)去逐个元素进行赋值
    // 下标就是地址偏移量,基于数组内存连续切元素大小相同的特性 偏移"下标"个元素的自身大小的字节
    // 语法 数组名[下标]
    printf("%d \n", arr1[0]);
    printf("%d \n", arr1[2]);
    // 下标语句支持取值与赋值
    // arr2[0] = 1;
    // arr2[1] = 3;
    // arr2[2] = 5;
    // arr2[3] = 7;
    // arr2[4] = 9;
```





## 数组元素引用

数组元素引用，指的是如何使用数组中的某个元素，数组中的元素都是有连续标号的，被称为数组下标，从0开始，依次递增。

- 存储模式：一片连续的内存，按数据类型分割成若干相同大小的格子
- 元素下标：数组开头位置的偏移量，a[0]引用第1个格子，a[1]引用第2个格子，以此类推

![5array2](.\img\5array2.png)

<div align="center">
    <P>
        元素下标偏移量
    </P>
</div>
![5array1](.\img\5array1.png)

<div align="center">
    <p>
        元素的内存地址计算
    </p>
</div>


```c
int a[5]; // 有效的下标范围是 0 ~ 4
a[0] = 1;
a[1] = 66;
a[2] = 21;
a[3] = 4;
a[4] = 934;

a[5] = 62; // 错误，越界了
a    = 10; // 错误，不可对数组名赋值 
```

因此结论很简单，对于任何的数组 `a[n]`，其有效引用范围是 `a[0] ~ a[n-1]`。



## 数组赋值

首先，<span style="color:red;">数组本质上是一系列连续存储的变量</span>，是可以对其进行赋值的，就使用上述元素引用的语法即可。但数组作为一个整体，是不可以直接赋值的，比如以下代码是错误的：

```c
int a[3];

a = 100;     // 错误！数组不可以整体赋值
a = {1,2,3}; // 错误！数组不可以整体赋值
```

- 那么，如果要对数组整体赋值，有这么几种方式：
  1. 使用数组初始化，直接提供一系列初始值进行赋值
  2. 使用循环，逐个元素赋值
  3. 使用memcpy函数，将一块内存整体复制到另一块内存

ps: memcpy

![5array_memcpy1](.\img\5array_memcpy1.png)

# 特殊数组

## 字符数组

- 概念：专门存放字符的数组，称为字符数组
- 初始化与元素引用：

```c
char s1[5] = {'a', 'b', 'c', 'd', 'e'};       // s1存放的是字符序列，非字符串
char s2[6] = {'a', 'b', 'c', 'd', 'e', '\0'}; // s2存放了一个字符串

char s[6] = {"abcde"}; // 使用字符串直接初始化字符数组
char s[6] =  "abcde" ; // 大括号可以省略

s[0] = 'A'; // 索引第一个元素，赋值为 'A'

// 我们发现 %s 本质接受一个地址,%s从这个地址向后读取字符直到\0
printf("%s \n", s)
```

// '\0'  ASCII码 为0  其作用是表示一段字符串的结束

字符串长度是字符起始位置到'\0'之间间隔多少个字符



字符型常量: \'A'

字符串常量: "abc"



字符串常量是一个匿名数组

![5arrstring](.\img\5arrstring.png)



## 多维数组

- 概念：若<span style="color:red;">数组元素类型也是数组</span>，则该数组称为多维数组
- 示例：

```c
int a[2][3];

// 代码释义：
// 1, a[2]   是数组的定义，表示该数组拥有两个元素
// 2, int [3]是元素的类型，表示该数组元素是一个具有三个元素的整型数组
```

![5array3](.\img\5array3.png)

- 多维数组的语法跟普通的一维数组语法完全一致
- 初始化：

```c
int a[2][3] = {{1,2,3}, {4,5,6}}; // 数组的元素是另一个数组

int a[2][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; // 错误，越界了
int a[2][3] = {{1,2,3}, {4,5,6,7}};        // 错误，越界了

int a[ ][3] = {{1,2,3}, {4,5,6}}; // OK，自动根据初始化列表分配数组元素个数
int a[2][3] = {{1,2,3}};          // OK，只初始化数组元素的一部分
```



```c
// arr是一个数组长度为[4]
    // 内部子元素是int [3] 类型
    // { {1,2,3}, {4,5,6}, {7,8,9}, {10,11,12} }
    // 从内存角度来说,连续的内存
    // 但是方便开发者理解, 我们会将其看做是 四行三列
    /*
        {
          {1,2,3},
          {4,5,6},
          {7,8,9},
          {10,11,12}
        }

    */
    // 二维数组完整初始化
    // int arr1[4][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
    //  二维数组初始化长度隐式声明
    // int arr2[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
    // 注意多维数组长度隐式声明只允许省略第一个中括号的长度,其他长度不可省略
    // int arr3[4][] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};

    // 部分初始化
    int arr4[4][3] = {1, 2, 3, 4};
    // arr4 表示首元素(int [3] 子数组)的地址
    // arr4[0] 表示 *arr4 地址范围缩小一级表示子数组内部首元素(int)的地址
    // arr4[0][0] 表示 **arr4 首子数组中首个子元素int的值
    printf("%d \n", arr4[0][0]);
    printf("%d \n", arr4[0][1]);
    printf("%d \n", arr4[0][2]);
    printf("%d \n", arr4[0][3]);

    printf("%d \n", **(arr4 + 1));
    printf("%d \n", arr4[1][0]);
    printf("%d \n", arr4[1][1]);
```



![7array](.\img\7array.png)

- 元素引用：

```c
// a[0] 代表第一个元素，这个元素是一个具有 3 个元素的数组：{1,2,3}
// a[1] 代表第二个元素，这个元素也是一个具有 3 个元素的数组：{4,5,6}

printf("%d", a[0][0]); // 输出第一个数组的第一个元素，即1
printf("%d", a[1][2]); // 输出第二个数组的第三个元素，即6
```

![5array4](.\img\5array4.png)

# 语法

- 任意的数组，不管有多复杂，其定义都由两部分组成。
  - 数组主体：说明数组名和元素个数。
  - 元素类型：说明元素的类型，可以是任意的类型（除了函数）

![5array6](.\img\5array6.png)

- 上述图例右侧代码说明：
  - age是数组名，有5个元素；每个元素都是`int`整型
  - gzw是数组名，有3个元素；每个元素都是`struct student`结构体
  - ids是数组名，有3个元素；每个元素都是`char [50]`字符数组
  - pts是数组名，有6个元素；每个元素都是`void(*)(int)`函数指针
- 元素类型如果由多个单词组成，C语言规定需要将其拆散写到数组主体的两边，如上述 `char[50]` 和 `void(*)(int)`。





