## 预处理

在C语言程序源码中，凡是以井号（#）开头的语句被称为预处理语句，这些语句严格意义上并不属于C语言语法的范畴，它们在编译的阶段统一由所谓预处理器（cc1）来处理。所谓预处理，顾名思义，指的是真正的C程序编译之前预先进行的一些处理步骤，这些预处理指令包括：

1. 头文件：#include
2. 定义宏：#define
3. 取消宏：#undef
4. 条件编译：#if、#ifdef、#ifndef、#else、#elif、#endif
5. 显示错误：#error
6. 修改当前文件名和行号：#line
7. 向编译器传送特定指令：#progma

- 基本语法
  - 一个逻辑行只能出现一条预处理指令，多个物理行需要用反斜杠连接成一个逻辑行
  - 预处理是整个编译全过程的第一步：预处理 - 编译 - 汇编 - 链接
  - 可以通过如下编译选项来指定来限定编译器只进行预处理操作：

```c
gcc example.c -o example.i -E
```



编译过程分为以下四个阶段：

1. **预处理**：处理预处理语句（#开头的语句），删除注释、头文件展开、宏替换...

```shell
gcc  hello.c  -o  hello.i  -E
```

2. **编译**: 将C语言程序转化为汇编语言 (机器语言)

```shell
gcc  hello.c  -o  hello.s  -S
```

3. **汇编**：将程序代码转化为二进制代码

```shell
gcc  hello.c  -o  hello.o   -c
```

4. **链接**：将所有二进制代码合并起来，根据应用规则生成一个专门针对某个平台执行的应用程序镜像

```shell
 gcc  hello.c  -o  hello
```



## 宏定义

宏（macro）实际上就是一段特定的字串，在源码中用以替换为指定的表达式。例如：

```c
#define PI 3.14
```



此处，PI 就是宏（宏一般习惯用大写字母表达，以区分于变量和函数，但这并不是语法规定，只是一种习惯），是一段特定的字串，这个字串在源码中出现时，将被替换为3.14。例如：

```c
int main()
{
    printf("圆周率: %f\n", PI); 
    // 此语句将被替换为：printf("圆周率: %f\n", 3.14);
}
```



- 宏的作用：
  - 使得程序更具可读性：字串单词一般比纯数字更容易让人理解其含义。
  - 使得程序修改更易行：修改宏定义，即修改了所有该宏替换的表达式。
  - 提高程序的运行效率：程序的执行不再需要函数切换开销，而是就地展开。



### 无参宏

无参宏意味着使用宏的时候，无需指定任何参数，比如：

```c
#define PI          3.14
#define SCREEN_SIZE 800*480*4 
int main()
{
    // 在代码中，可以随时使用以上无参宏，来替代其所代表的表达式：
    printf("圆周率: %f\n", PI); 
    mmap(NULL, SCREEN_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, ...);
}
```



注意到，上述代码中，除了有自定义的宏，还有系统预定义的宏：

```c
// 自定义宏:
#define PI          3.14
#define SCREEN_SIZE 800*480*4 

// 系统预定义宏
#define NULL ((void *)0)
#define PROT_READ	0x1	    /* Page can be read.  */
#define PROT_WRITE	0x2	    /* Page can be written.  */
#define MAP_SHARED	0x01	/* Share changes.  */
```



宏的最基本特征是进行直接文本替换，以上代码被替换之后的结果是：

```c
int main()
{
    printf("圆周率: %f\n", 3.14); 
    mmap(((void *)0), 800*480*4, 0x1|0x2, 0x01, ...);
}
```



### 带参宏

带参宏意味着宏定义可以携带“参数”，从形式上看跟函数很像，例如：

```c
#define MAX(a, b)   a>b ? a : b
#define MIN(a, b)   a<b ? a : b
```



以上的MAX(a,b) 和 MIN(a,b) 都是带参宏，不管是否带参，宏都遵循最初的规则，即宏是一段待替换的文本，例如在以下代码中，宏在预处理阶段都将被替换掉：

```c
int main()
{
    int x = 100, y = 200;
    printf("最大值:%d\n", MAX(x, y));
    printf("最小值:%d\n", MIN(x, y));
    // 以上代码等价于:
    // printf("最大值:%d\n", x>y ? x : y);
    // printf("最小值:%d\n", x<y ? x : y);
}
```



- 带参宏的特点：
  1. 直接文本替换，不做任何语法判断，更不做任何中间运算。
  2. 宏在编译的第一个阶段就被替换掉，运行中不存在宏。
  3. 宏将在所有出现它的地方展开，这一方面浪费了内存空间，另一方面有节约了切换时间。

**带参宏的副作用**
由于宏仅仅做文本替换，中间不涉及任何语法检查、类型匹配、数值运算，因此用起来相对函数要麻烦很多。例如：

```c
#define MAX(a, b) a>b ? a : b

int main()
{
    int x = 100, y = 200;
    printf("最大值:%d\n", MAX(x, y==200?888:999));
}
```



直观上看，无论 y 的取值是多少，表达式 y==200?888:999 的值一定比 x 要大，但由于宏定义仅仅是文本替换，中间不涉及任何运算，因此等价于：

```c
printf("最大值:%d\n", x>y==200?888:999 ? x : y==200?888:999);
```



可见，带参宏的参数不能像函数参数那样视为一个整体，整个宏定义也不能视为一个单一的数据，事实上，不管是宏参数还是宏本身，都应被视为一个字串，或者一个表达式，或者一段文本，因此最基本的原则是：

- 将宏定义中所有能用括号括起来的部分，都括起来，比如：

```c
#define MAX(a, b) ((a)>(b) ? (a) : (b))
```



### 宏的符号粘贴

有些时候，宏参数中的符号并非用来传递数据，而是用来形成多种不同的字串，例如在某些系统函数中，系统本身规范了函数接口的部分标准，形如：

```c
void __zinitcall_service_1(void)
{
    ...
}

void __zinitcall_service_2(void)
{
    ...
}

void __zinitcall_feature_1(void)
{
    ...
}

void __zinitcall_feature_2(void)
{
    ...
}
```



此时，若需要向用户提供一个方便整合字串的宏定义，可以这么写：

```c
#define LAYER_INITCALL(num, layer)  __zinitcall_##layer##_##num
```



用户的调用如下：

```c
LAYER_INITCALL(service, 1);
LAYER_INITCALL(service, 2);
LAYER_INITCALL(feature, 1);
LAYER_INITCALL(feature, 2);
```



**注意：**
在书写非字符串的字串时（如上述例子），使用两边双井号来**粘贴**字串，并且要注意如果字串出现在最末尾，则最后的双井号必须去除，例如上述代码不可写成：

```c
#define LAYER_INITCALL(num, layer)  __zinitcall_##layer##_##num##
```



但如果粘贴的字串并非出现在最末尾，则前后都必须加上双井号：

```c
#define LAYER_INITCALL(num, layer)  __zinitcall_##layer##_##num##end
```



**注意：**
另外，如果字串本身拼接为字符串，那么只需要使用一个井号即可，比如：

```c
#define domainName(a, b) "www." #a "." #b ".com"

int main()
{
    printf("%s\n", domainName(yueqian, lab));
}
```



执行打印如下：

```c
gec@ubuntu:~$ ./a.out
www.yueqian.lab.com
gec@ubuntu:~$
```



### 无值宏定义

定义无参宏的时候，不一定需要带值，无值的宏定义经常在条件编译中作为判断条件出现，例如：

```c
#define BIG_ENDIAN
#define __cplusplus
```



### 复杂的宏定义

在C语言中，宏定义可以非常复杂，并且可以用于生成相当复杂的代码片段。通过结合参数、操作符、条件和嵌套宏，可以创建出功能强大的宏。以下是一些复杂宏定义的例子：

```c
#define IS_EVEN(x) ((x) % 2 == 0)  
#define PRINT_NUMBERS(n) do { \  
    int i; \  
    for (i = 0; i < (n); ++i) { \  
        if (IS_EVEN(i)) { \  
            printf("%d is even\n", i); \  
        } else { \  
            printf("%d is odd\n", i); \  
        } \  
    } \  
} while (0)
```



在这个例子中，IS_EVEN 是一个简单的宏，用于检查一个数是否是偶数。PRINT_NUMBERS 是一个更复杂的宏，它使用 do { ... } while (0) 结构来模拟一个语句块，并在其中使用了一个 for 循环来打印从0到 n-1 的所有整数，同时标记每个数是偶数还是奇数。



### 预定义宏



```c
1）预处理日期和时间
__DATE__ 、__TIME__
2) 函数名  和  当前行
__FUNCTION__、 ___LINE__
3)文件名
__FILE__
```



### \#和\##

\#

```c
#include <stdio.h>
int main()
{
    char *str = "hello" "world";
    printf("str = %s\n", str);  
    return 0;
}
```

结果:

​	str = helloworld

结论：字符串是由自动连接的特点



使用\#符号，把一个宏参数变成对应的字符串

```c
#include <stdio.h>
#define CHANGE(STR)  #STR  // #将文本STR转换成字符串
int main()
{
    char *str = "hello" "world" "ikun";
    printf("str = %s\n", str);
    printf("CHANGE(STR)= %s\n", CHANGE(ikun i love you));    // #ikun i love you 转成"ikun i love you"
    return 0;
}
```



\##可以把位于它两边的符号合成一个符号，它允许宏定义从分离的文本片段创建标识符

```c
#include <stdio.h>
#define STRCAT(str1, str2)   str1##str2  // 将str1和str2标识连在一起
int main()
{
    int sum5 = 100;
    printf("sum5 =  %d\n", STRCAT(sum, 5));
    return 0;
}
```



注意：这样的连接必须产生一个合法的标识符。否则其结果就是未定义的,连接是在预处理的时候进行的



# 宏和内联

C语言中的内联函数和宏函数都是用于优化代码性能的工具，但它们之间存在一些重要的区别。

1. 编译时处理
   - 宏函数：宏函数在预处理阶段由预处理器处理。预处理器会直接将宏函数替换为它的定义，然后再进行编译。因此，宏函数没有类型检查，也没有作用域，只是简单的文本替换。
   - 内联函数：内联函数在编译时被处理。编译器会在调用内联函数的地方直接插入或替换内联函数的代码，从而避免函数调用的开销。内联函数有类型检查，也有作用域。

2. 参数处理
   - 宏函数：由于宏函数只是文本替换，因此参数在替换过程中可能会引发一些意料之外的问题，比如运算符优先级问题。为了避免这些问题，宏函数的参数通常需要用括号包围。
   - 内联函数：内联函数在参数处理上就像普通的函数一样，有明确的参数类型和参数传递方式，因此不需要担心运算符优先级等问题。

3. 调试和可读性
   - 宏函数：由于宏函数是文本替换，因此在调试时可能会比较困难，因为预处理器已经将宏函数替换为了它的定义，所以无法在调试器中看到宏函数的调用。此外，由于宏函数没有明确的作用域和类型检查，因此可能会降低代码的可读性和可维护性。

   - 内联函数：内联函数像普通的函数一样，可以在调试器中看到其调用和执行过程，因此更易于调试。此外，内联函数有明确的作用域和类型检查，因此可以提高代码的可读性和可维护性。

4. 适用场景

   - 宏函数：通常用于执行简单的、不需要复杂逻辑或类型检查的操作，或者用于定义一些常量或简单的计算式。宏可以循环 switch
   - 内联函数：适用于那些函数体较小，但又频繁调用的函数。通过内联可以减少函数调用的开销，提高程序的执行效率。内敛不可以循环 switch

