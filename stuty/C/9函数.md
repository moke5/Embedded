## 函数入门

### 基本概念

在C语言中，函数意味着功能模块。一个典型的C语言程序，就是由一个个的功能模块拼接起来的整体。也因为如此，C语言被称为模块化语言。

对于函数的使用者，可以简单地将函数理解为一个黑箱，使用者只管按照规定给黑箱一些输入，就会得到一些输出，而不必理会黑箱内部的运行细节。

![8function1](.\img\8function1.png)

日常使用的电视机可以被理解为一个典型的黑箱，它有一些公开的接口提供给使用者操作，比如开关、音量、频道等，使用者不需要理会其内部电路，更不需要管电视机的工作原理，只需按照规定的接口操作接口得到结果。

对于函数的设计者，最重要的工作是封装，封装意味着对外提供服务并隐藏细节。对于一个封装良好的函数而言，其对外提供服务的接口应当是简洁的，内部功能应当是明确的。



#### 函数定义

函数定义即函数代码的真正实现，跟变量定义一样，所谓定义就是系统编译时会为之分配一块适当大小的内存来存储其代码。

- 典型函数定义的语法如下：

```
返回类型 函数名称(参数1, 参数2, ……)
{
    函数体
}
```



- 函数头：第一行称为函数头，或称函数特征表，是函数对外的公开接口
  1. 函数名称：命名规则与跟变量一致，一般取与函数实际功能相符合的、顾名思义的名称。
  2. 参数列表：即黑箱的输入数据列表，一个函数可有一个或多个参数，也可以不需要参数。
  3. 返回类型：即黑箱的输出数据类型，一个函数可不返回数据，但最多只能返回一个数据。
- 函数体：花括号 `{ ... }` 内为函数体，是函数功能的内部实现
- 函数示例1：求两个给定整数的最大值

```c
int max(int x, int y) // 该函数接收两个整型参数，并返回一个整型数据
{
    int z;
    z = x>y ? x : y;
    return z;
} 
```



- 函数示例2：交换两个浮点数

```c
void swap(double *p1, double *p2) // 该函数接收两个浮点指针参数，不返回数据
{
    if(p1 == NULL || p2 == NULL)
        return;
        
    double tmp;
    tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
} 
```



- 函数示例3：初始化液晶屏，获取显存入口指针

```c
char * initLCD(void) // 该函数不接受参数，返回一个字符指针
{
    int lcd = open("/dev/fb0", O_RDWR);
    
    struct fb_var_screeninfo vinfo;
    ioctl(lcd, FBIOGET_VSCREENINFO, &vinfo);
    int bpp  = vinfo.bits_per_pixel;
    int size = vinfo.xres * vinfo.yres * bpp/8;
    
   char * fbmem = mmap(NULL, size, PROT_READ, MAP_SHARED, lcd, 0);
   return fbmem;
} 
```



- 语法汇总：
  1. 当函数的参数列表为 void 时，表示该函数不需要任何参数。
  2. 当函数的返回类型为 void 时，表示该函数不返回任何数据。
  3. 关键字 return 表示退出函数。①若函数头中规定有返回数据类型，则 return 需携带一个类型与之匹配的数据；②若函数头中规定返回类型为 void，则 return 不需携带参数。



#### 函数调用

有了函数的定义之后，就可以使用这个函数了，这就是函数的调用。以上述示例1的代码为例，调用此函数求得两个数的最大值，完整的代码如下：

```c
int max(int x, int y) // 该函数接收两个整型参数，并返回一个整型数据
{
    int z;
    z = x>y ? x : y;
    return z;
} 

int main(void)
{
    int a = 1;
    int b = 2;
    int m;
        
    m = max(a, b); // 调用函数 max()，将 a 和 b 作为实参传入，将返回值赋给 m
    printf("m = %d\n", m);
}
```



上述代码中，`m = max(a, b);` 这一行代码就是函数调用，函数调用时必须携带圆括号 `()`，里面依次放入函数定义中所规定的参数列表，参数的类型、个数、顺序都必须跟定义一致。



#### 函数声明

以上函数的定义和调用是在同一文件中，但一般情形下，工程文件都会按功能分开存储在不同的源码文件中，比如 `max()` 函数定义在 `max.c` 文件中，而 `main()` 函数定义在 `main.c` 文件中，此时就需要在 `main.c` 文件中声明 `max()` 函数，否则编译器无法识别 `max()` 函数。

声明函数的语法如下：

```
返回类型 函数名称(参数1, 参数2, ……);
```



以上述为例，完整的代码如下：

```c
// max.c
int max(int x, int y) // 该函数接收两个整型参数，并返回一个整型数据
{
    int z;
    z = x>y ? x : y;
    return z;
} 
```



```c
// main.c
#include <stdio.h>

int max(int x, int y); // 声明函数 max()

int main(void)
{
    int a = 1;
    int b = 2;
    int m;
    m = max(a, b); // 调用函数 max()，将 a 和 b 作为实参传入，将返回值赋给 m
    printf("m = %d\n", m);
}
```



注意，必先声明，再调用，顺序不可反。

声明的时候可以不写形参变量名



### 概念

#### 形参实参

- 概念：
  - 函数调用中的参数，被称为实参，即 arguments
  - 函数定义中的参数，被称为形参，即 parameters
- 实参与形参的关系：
  - 实参于形参的类型和个数必须一一对应。
  - 形参的值由实参初始化。
  - 形参与实参位于不同的内存区域，彼此独立。
- 示例：

```c
// 函数定义中，x、y都属于形参，位于函数 max 的栈内存中
// 它们的值由实参一一对应初始化
int max(int x, int y)
{
    int z;
    z = x>y ? x : y;
    return z;
}

int main(void)
{
    int a = 1;
    int b = 2;
    int m;
        
    // 函数调用中，a、b都属于实参，存储于主函数 main 的栈内存中
    m = max(a, b);    
}
```

<span style="color:red;">任何数据类型，想要在某个函数内修改外部变量，函数必须接收的是外部变量的地址</span>



#### 函数调用的流程

函数调用时，进程的上下文会切换到被调函数，当被调函数执行完毕之后再切换回去。

![8function2](.\img\8function2.png)

<div align="center">
    <p>
        函数调用时代码的执行流程
    </p>
</div>

#### 局部变量与栈内存

- 局部变量概念：凡是被一对花括号包含的变量，称为局部变量
- 局部变量特点：
  - 某一函数内部的局部变量，存储在该函数特定的栈内存中
  - 局部变量只能在该函数内可见，在该函数外部不可见
  - 当该函数退出后，局部变量所占的内存立即被系统回收，因此局部变量也称为临时变量
  - 函数的形参虽然不被花括号所包含，但依然属于该函数的局部变量
- 栈内存特点：
  - 每当一个函数被调用时，系统将自动分配一段栈内存给该函数，用于存放其局部变量
  - 每当一个函数退出时，系统将自动回收其栈内存
  - 系统为函数分配栈内存时，遵循从上（高地址）往下（低地址）分配的原则

- 示例代码：

```c
int max(int x, int y) // 变量 x 和 y 存储在max()函数的栈中
{
    int z;            // 变量 z 存储在max()函数的栈中
    z = x>y ? x : y;
    return z;         // 函数退出后，栈中的x、y 和 z 被系统回收
}

int main(void)
{
    int a = 1; // 变量 a 存储在main()函数的栈中
    int b = 2; // 变量 b 存储在main()函数的栈中
    int m;     // 变量 m 存储在main()函数的栈中，未赋值因此其值为随机值
    
    m = max(a, b);
}
```

![8function3](.\img\8function3.png)

<div align="center">
    <p>
        函数调用时代码的执行流程
    </p>
</div>

- 技术要点：
  - 栈内存相对而言是比较小的，不适合用来分配尺寸太大的变量。
  - return 之后不可再访问函数的局部变量，因此返回一个局部变量的地址通常是错误的。



##　main函数传参

```c
//int  main(int argc,char**argv)
int  main(int argc,char*argv[])
{
}
参数：
    argc---从命令行中传递进来的字符串的个数
    argv---从命令行中传递的字符串数据存储在该指针所指向的数组中
可参考 《C Primer Plus》第836页进行辅助讲解
比如执行的时候  ./a.out  1.c  2.c
那么 argc--->3
argv[0] ----"./a.out"
argv[1] ----"1.c"
argv[2] ----"2.c"
```



## 函数指针

把函数头置为(*p) 使用跟函数使用一致



## 特殊函数

### 静态函数

- 背景知识：普通函数都是跨文件可见的，即在文件 a.c 中定义的函数可以在 b.c 中使用。
- 静态函数：只能在定义的文件内可见的函数，称为静态函数。
- 语法：

```c
staitc void f(void) // 在函数头前面增加关键字 static ，使之成为静态函数
{
    // 函数体
}
```



- 要点：
  - 静态函数主要是为了缩小函数的可见范围，减少与其他文件中重名函数冲突的概率。
  - 静态函数一般被定义在头文件中，然后被各个源文件包含。



### 递归函数

- 递归概念：如果一个函数内部，包含了对自身的调用，则该函数称为递归函数。
- 递归问题：
  - 阶乘。
  - 幂运算。
  - 字符串翻转。
- 要点：
  - 只有能被表达为递归的问题，才能用递归函数解决。
  - 递归函数必须有一个可直接退出的条件，否则会进入无限递归。
  - 递归函数包含两个过程，一个逐渐递进的过程，和一个逐渐回归的过程。
- 示例：依次输出 n 个自然数。
- 思路：先输出前面的 n-1 个自然数，再输出最后一个自然数 n 。而要输出前面的 n-1 个自然数，递归调用自身即可。

```c
// 该函数的功能：依次输出 n 个自然数
void f(int n) 
{
    if(n < 0)          // 1，当满足此条件时，不再进行递归。
        return;
        
    f(n-1);            // 2，递归调用自己，输出前 n-1 个数
    printf("%d\n", n); // 3，输出最后一个自然数 n
}
```



- 递归调用时，函数的栈内存的变化如下图所示。可见，随着递归函数的层层深入，栈空间逐渐往下增长，如果递归的层次太深，很容易把栈内存耗光。
- 层层递进时，问题的规模会随之减小，减小到可直接退出的条件时，函数开始层层回归。

![8function4](.\img\8function4.png)

### 回调函数(钩子函数)

- 概念：函数实现者不调用该函数，而由函数接口提供者间接调用的函数，称为回调函数。
- 示例：系统中的信号处理，是一个典型的利用回调函数的情形。

![8function5](.\img\8function5.png)

<div align="center">
    <p>
        信号处理
    </p>
</div>



- 要点：
  - 示例中函数 sighandler 是回调函数。
  - signal() 将函数回调函数传递给内核，使得内核可以在恰当的时机回调 sighandler。
  - 应用开发者和内核开发者只要约定好回调函数的接口，即可各自开发，进度互不影响。



### 内联函数

函数调用时，系统需要为函数调用分配栈空间，函数返回时，系统需要释放栈空间，这一来一回的操作都会带来一定的开销。

函数可以类比为一台打印机，普通函数就是一台大家公用的打印机，有人想要打印资料的时候，就拿着参数跑过去打印，打完回到自己的工位继续干活。这样的好处是全公司共用一台打印机（所有调用共用一段定义代码），节省成本（内存空间），代价是每次打印都得跑来跑去，浪费时间。

内联函数，就是公司给每个员工都配备一台打印机，每当员工需要打印资料的时候，不需要跑来跑去，而是直接在自己的工位上打印，节省了时间，代价是公司要为每个员工配备一台打印机，增加了成本（内存空间）。

理解了上述逻辑，就理解了什么是内联函数，也理解了什么时候该使用内联函数：

1. 当一个函数被频繁调用时。（如果函数被调用次数很少，那么内联函数就没意义了）
2. 当一个函数足够短小精悍时。（如果函数体很大，执行时间很长，那所节约的来回跑的那一丁点时间也没意义了）

内联函数语法很简单，只需在函数头前加一个 `inline` 即可，但内联函数跟普通函数还有一个区别：其默认情况下不会编译生成可被链接的符号（Symbol），因此必须与 `extern` 或 `static` 配合使用，来说明该内联函数是全局符号还是局部符号，如下所示：

```c
extern inline void global_inline_func(void) // 加上 extern 声明，编译时为其生成全局链接符号，可以被其他文件调用
static inline void local_inline_func(void) // 加上 static 声明，编译时为其生成局部链接符号，只能被本文件调用
{
    // 函数体
}
```



一般常见做法，就是将内联函数定义在头文件中，并加上 `static` 声明，然后被各个源文件包含。

```c
// head.h
static inline void local_inline_func(void)
{
    printf("我是inline内联函数\n");
}
```



```c
// main.c
#include "head.h"

int main(void)
{
    local_inline_func();
    return 0;
}
```



### 弱函数

在C语言中，函数定义无法重复，一旦重复定义编译就会马上报错，但考虑这么一种场景：某个软件模块在出厂时，需要给用户提供一个默认的函数实现，而用户也可以根据需要，自行提供该函数实现，那么此时，如何处理函数定义的重复问题呢？弱函数就可以派上用场了。

弱函数是一类非常重要的特殊函数，其作用是给函数定义增加一层保护，防止函数定义重复。弱函数的语法很简单，只需在函数头前加一个 `__attribute__((weak))` 即可，如下所示：

```c
// a.c
__attribute__((weak)) void weak_func(void)
{
    // 默认的函数功能
}
```



这样一来，用户可以根据需要，来自定决定要使用默认的函数功能，还是自行定义函数功能，如果要自定定义的话，直接在源文件中重新定义该函数即可，如下所示：

```c
// main.c
#include "head.h"

void weak_func(void) // 重新定义 weak_func 函数
{
    // 自定义的函数功能
}
```



注意，此时虽然 `a.c` 和 `main.c` 都有重名函数 `weak_func()` ，但不会报错，因为它是弱函数，编译器会优先使用 `main.c` 中的版本，而忽略 `a.c` 中的 `weak_func()` 函数。



## 字符串函数

### 查找字串strstr

![9string_strstrpng](.\img\9string_strstrpng.png)

- 示例：

```c
char *s = "abcd.txt";
char *p = strstr(s, ".wps");

if(p == NULL)
    printf("文件[%s]不是WPS文件\n", s);
else
    printf("文件[%s]是WPS文件\n", s);
```



### 查找字符strchr()和strtchr()

![9strchr_strrchr](.\img\9strchr_strrchr.png)

- 注意：
  1. 这两个函数的功能，都是在指定的字符串 s 中，试图找到字符 c。
  2. strchr() 从左往右找，strrchr() 从右往左找。
  3. 字符串结束标记 ‘\0’ 被认为是字符串的一部分。
- 示例：

```c
char *p;

p = strchr("www.qq.com", '.'); // 从左到右找到第一个出现的字符'.'
printf("%s\n", p);             // 输出 ".qq.com"

p = strrchr("www.qq.com", '.');// 从右到左找到第一个出现的字符'.'
printf("%s\n", p);             // 输出 ".com"
```



### 计算长度strlen()

![9stringstrlen](.\img\9stringstrlen.png)

- 示例：

```c
char *s = "www.yueqian.com.cn";
printf("粤嵌官网地址的长度是：%d\n", strlen(s));
```



### 字串切割strtok()

![9stringstrtok](.\img\9stringstrtok.png)

- 注意：
  1. 该函数会将改变原始字符串 str，使其所包含的所有分隔符变成结束标记 ‘\0’ 。
  2. 由于该函数需要更改字符串 str，因此 str 指向的内存必须是可写的。
  3. 首次调用时 str 指向原始字符串，此后每次调用 str 用 NULL 代替。
- 示例：

```c
char s[20] = "www.yueqian.com.cn";

char *p = strtok(s, ".");  // 首次调用时，s 指向需要分割的字符串
while(p != NULL)
{
    printf("%s\n", p);
    p = strtok(NULL, "."); // 此后每次调用，均使用 NULL 代替。
}
```



*注：上述代码的运行结果就是将字符串 s 拆解为"www"、“yueqian”、“com” 和 “cn”*



### 字串拼接strcat()和strncat()

![9strcatstrncat](.\img\9strcatstrncat.png)

- 注意：
  1. 这两个函数的功能，都是将 src 中的字符串，复制拼接到 dest 的末尾。
  2. strcat() 没有边界控制，因此可能会由于 src 的过长而导致内存溢出。
  3. strncat() 有边界控制，最多复制 n+1 个字符（其中最后一个是 ‘\0’ ）到 dest 的末尾。
- 示例：

```c
char s1[10] = "abc";
strcat(s1, "xyz");
printf("%s\n", s1); // 输出 "abcxyz"

char s2[10] = "abc";
strcat(s3, "123456789"); // 此处操作内存溢出，可能会发生内存崩溃


char s[10]  = "abc";
strncat(s, "123456789", sizeof(s)-strlen(s)-1);
printf("%s\n", s); // 输出 "abc123456"，两个字符串被拼接到了一起，且不会溢出
```



- 注意：strncat()是具备边界检查的安全版本，推荐使用。



### 字串拷贝strcpy()和strncpy()

![9strcpystrncpy](.\img\9strcpystrncpy.png)

- 注意：
  1. 这两个函数的功能，都是将 src 中的字符串，复制到 dest 中。
  2. strcpy() 没有边界控制，因此可能会由于 src 的过长而导致内存溢出。
  3. strncpy() 有边界控制，最多复制 n+1 个字符（其中最后一个是 ‘\0’ ）到 dest 中。
- 示例：

```c
char s1[5] = "abc";
strcpy(s1, "xyz);
printf("%s\n", s1); // 输出 "xyz"，原有的"abc"被覆盖

char s2[5] = "abc";
strcpy(s2, "123456789"); // 此处操作内存溢出，可能会发生内存崩溃
```



```c
char s[5] = "abc";
strncpy(s, "123456789", sizeof(s)-1);
printf("%s\n", s); // 输出 "1234"，有边界保护，不会溢出
```



- 注意：strncpy()是具备边界检查的安全版本，推荐使用。



### 字串比较strcmp()和strncmp()

![8strcmpstrncmp](.\img\8strcmpstrncmp.png)

- 注意：
  - 比较字符串大小，实际上比较的是字符的 ASCII码值的大小。
  - 从左到右逐个比较两个字符串的每一个字符，当能“决出胜负”时立刻停止比较。
- 示例：

```c
printf("%d\n", strcmp("abc", "abc")); // 输出0，两个字符串相等
printf("%d\n", strcmp("abc", "aBc")); // 输出1，"abc" 大于 "aBc"
printf("%d\n", strcmp("999", "aaa")); // 输出-1，"999" 小于 "aaa"
```
