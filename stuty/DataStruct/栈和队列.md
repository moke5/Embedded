## 栈

栈（stack）是一种遵循先入后出逻辑的线性数据结构。



### 基于链表



```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
} Node;

typedef struct
{
    struct node *top; // 栈顶
    int size;         // 栈的大小
} LinkedListStack;

LinkedListStack *newLinkedListStack()
{
    LinkedListStack *s = malloc(sizeof(LinkedListStack));
    if (s == NULL)
    {
        perror("newLinkedListStack failed!\n");
        return NULL;
    }

    s->size = 0;
    s->top = NULL;
    return s;
}

int isEmpty(LinkedListStack *s)
{
    return s->size == 0;
}

// 入栈
int push(LinkedListStack *s, int data)
{
    // 从栈顶添加一个链表节点 (头插)
    // 让栈的 size++
    Node *n = malloc(sizeof(Node));
    if (n == NULL)
    {
        perror("push failed!\n");
        return -1;
    }

    n->data = data;
    n->next = s->top;
    s->top = n;
    s->size++;
    return data;
}

// 出栈
int pop(LinkedListStack *s)
{
    if (isEmpty(s))
    {
        printf("栈为空!\n");
        return -1;
    }
    // 从栈顶添加一个链表节点 (头删)

    Node *n = s->top;
    s->top = n->next;
    int res = n->data; // 目的将出战元素的值返回到函数外部
    free(n);
    // 让栈的 size--
    s->size--;
    return res;
}

int peek(LinkedListStack *s)
{
    if (isEmpty(s))
    {
        printf("栈为空! \n");
        return -1;
    }

    return s->top->data;
}

void delLinkedListStack(LinkedListStack *s) {
    while (!isEmpty(s))
    {
        pop(s);
    }
    free(s);
}

int main(int argc, char const *argv[])
{
    LinkedListStack *s = newLinkedListStack();
    push(s, 10);
    push(s, 9);

    delLinkedListStack(s);

    printf("%d \n", peek(s));

    return 0;
}

```



### 基于内核链表



```c
#include <stdio.h>
#include <stdlib.h>
#include "kernel_list.h"

typedef struct
{
    int data;
    struct list_head list;
} Node;

typedef struct
{
    Node *top; // 栈顶
    int size;  // 栈的大小
} LinkedListStack;

LinkedListStack *newLinkedListStack()
{
    LinkedListStack *s = malloc(sizeof(LinkedListStack));
    if (s == NULL)
    {
        perror("newLinkedListStack failed!\n");
        return NULL;
    }

    s->size = 0;
    s->top = malloc(sizeof(Node));
    if (s->top == NULL)
    {
        perror("create s->top failed!\n");
        free(s);
        return NULL;
    }

    INIT_LIST_HEAD(&(s->top->list));
    return s;
}

int isEmpty(LinkedListStack *s)
{
    return s->size == 0;
}

int push(LinkedListStack *s, int data)
{
    Node *n = malloc(sizeof(Node));
    if (n == NULL)
    {
        perror("push failed!\n");
        return -1;
    }

    n->data = data;
    list_add(&n->list, &(s->top->list));
    s->size++;

    return data;
}

int peek(LinkedListStack *s)
{

    if (isEmpty(s)) {
        printf("栈为空!\n");
        return -1;
    }

    // 小结构体转大结构体
    Node *n = list_entry(s->top->list.next, Node, list);

    return n->data;
}

int pop(LinkedListStack *s)
{
    if (isEmpty(s))
    {
        printf("栈为空!\n");
        return -1;
    }

    int res = peek(s);
    struct list_head *smallN = s->top->list.next;
    list_del(smallN);

    Node *bigN = list_entry(smallN, Node, list);
    free(bigN);
    s->size--;
    return res;
}

void delLinkedListStack(LinkedListStack *s)
{
    while (!isEmpty(s))
    {
        pop(s);
    }
    free(s->top);
    free(s);
}

int main(int argc, char const *argv[])
{
    LinkedListStack *s = newLinkedListStack();
    push(s, 10);
    push(s, 9);
    push(s, 8);

    push(s, 7);

    printf("%d \n", pop(s));

    delLinkedListStack(s);

    return 0;
}
```



### 基于数组



```c
#include <stdio.h>
#include <stdlib.h>

typedef struct
{
    int capacity; // 总容量
    int size;     // 入栈元素的个数
    int *data;
} ArrayStack;

ArrayStack *newArrayStack(int capacity)
{
    ArrayStack *s = malloc(sizeof(ArrayStack));
    if (s == NULL)
    {
        perror("newArrayStack malloc ArrayStack failed!\n");
        return NULL;
    }

    s->capacity = capacity;
    s->size = 0;
    s->data = malloc(sizeof(int) * capacity);
    if (s->data == NULL)
    {
        perror("newArrayStack malloc data failed!\n");
        free(s);
        return NULL;
    }

    return s;
}

int isFull(ArrayStack *s)
{
    return s->size >= s->capacity;
}

void push(ArrayStack *s, int data)
{
    if (isFull(s))
    {
        printf("栈已满!\n");
        return;
    }

    s->data[(s->size)++] = data;
}

int isEmpty(ArrayStack *s)
{
    return s->size == 0;
}

int peek(ArrayStack *s)
{
    if (isEmpty(s))
    {
        printf("栈为空!\n");
        return -1;
    }

    return s->data[s->size - 1];
}

int pop(ArrayStack *s)
{
    if (isEmpty(s))
    {
        printf("栈为空!\n");
        return -1;
    }

    int res = peek(s);
    s->size--; // 出栈
    return res;
}

void delArrayStack(ArrayStack *s) {
    
    free(s->data);
    free(s);
}

int main(int argc, char const *argv[])
{
    ArrayStack *s = newArrayStack(100);
    if (s == NULL)
    {
        return -1;
    }

    push(s, 7);
    push(s, 8);
    push(s, 9);
    push(s, 10);

    printf("%d \n", peek(s));
    printf("%d \n", pop(s));
    printf("%d \n", pop(s));
    printf("%d \n", pop(s));
    printf("%d \n", pop(s));
    printf("%d \n", pop(s));
    return 0;
}
```



## 队列

队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。

### 单链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
} Node;

typedef struct
{
    int size;
    struct node *front, *rear;
} LinkedListQueue;

/* 构造函数 */
LinkedListQueue *newLinkedListQueue()
{
    LinkedListQueue *q = malloc(sizeof(LinkedListQueue));
    if (q == NULL)
    {
        perror("newLinkedListQueue failed!\n");
        return NULL;
    }
    q->size = 0;
    q->rear = NULL;
    q->front = NULL;
    return q;
}

// 判断队列是否为空
int isEmpty(LinkedListQueue *q)
{
    return q->size == 0;
}

// 入队
void push(LinkedListQueue *q, int data)
{
    Node *n = malloc(sizeof(Node));
    if (n == NULL)
    {
        perror("push malloc failed!\n");
        return;
    }
    n->data = data;
    n->next = NULL;

    if (isEmpty(q))
    {
        // 若队列为空队列第一个入队元素既是队首也是队尾
        q->front = n;
    }
    else
    {
        q->rear->next = n;
    }

    q->rear = n; // 让节点变为新的队尾
    q->size++;
}

// 访问队首元素
int peek(LinkedListQueue *q)
{
    if (isEmpty(q))
    {
        printf("队列为空!\n");
        return -1;
    }
    return q->front->data;
}

int pop(LinkedListQueue *q)
{
    if (isEmpty(q))
    {
        return -1;
    }
    // 获取队首元素的值,用于返回到函数外部
    int res = peek(q);

    Node *tmp = q->front;
    q->front = q->front->next;
    free(tmp);
    q->size--;

    return res;
}

void delLinkedListQueue(LinkedListQueue *q) {
    while (!isEmpty(q))
    {
        pop(q);
    }
    free(q);
}

int main(int argc, char const *argv[])
{
    LinkedListQueue *que = newLinkedListQueue();
    if (que == NULL)
    {
        return -1;
    }

    push(que, 7);
    push(que, 8);
    push(que, 9);
    push(que, 10);

    // printf("%d \n", pop(que));
    // printf("%d \n", pop(que));
    // printf("%d \n", pop(que));
    // printf("%d \n", pop(que));
    // printf("%d \n", pop(que));

    delLinkedListQueue(que);

    Node *p = que->front;
    while (p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }

    printf("\n");

    return 0;
}
```





### 数组



```c
#include <stdio.h>
#include <stdlib.h>

typedef struct
{
    int front;
    // int rear;
    int size; // 因为数组物理连续 队尾可以通过 front 和 size计算出来
    int capacity;
    int *data;
} ArrayQueue;

ArrayQueue *newArrayQueue(int capacity)
{
    ArrayQueue *q = malloc(sizeof(ArrayQueue));

    if (q == NULL)
    {
        perror("newArrayQueue failed!\n");
        return NULL;
    }
    q->capacity = capacity;
    q->size = 0;
    q->front = 3;
    q->data = malloc(sizeof(int) * capacity);
    if (q->data == NULL)
    {
        perror("newArrayQueue malloc  q->data failed!\n");
        free(q);
        return NULL;
    }

    return q;
}

int isFull(ArrayQueue *q)
{
    return q->size >= q->capacity;
}

int isEmpty(ArrayQueue *q)
{
    return q->size == 0;
}

// 入队
void push(ArrayQueue *q, int data)
{

    if (isFull(q))
    {
        printf("队列已满!\n");
        return;
    }

    // 先根据队首值与size值计算出入队时队尾的下标
    // 因为数组需要循环复用,这里需要取余
    int rear = (q->front + q->size) % q->capacity;

    // printf("rear: %d \n", rear);
    q->data[rear] = data;
    q->size++;
}

int peek(ArrayQueue *q)
{
    if (isEmpty(q))
    {
        return -1;
    }

    return q->data[q->front];
}

// 出队
int pop(ArrayQueue *q)
{
    if (isEmpty(q))
    {
        printf("队列为空 !\n");
        return -1;
    }

    int res = peek(q);
    q->front = (q->front + 1) % q->capacity;
    q->size--;
    return res;
}

void delArrayQueue(ArrayQueue *q) {
    free(q->data);
    free(q);
}

int main(int argc, char const *argv[])
{
    ArrayQueue *que = newArrayQueue(5);

    push(que, 1);
    push(que, 2);
    push(que, 3);

    printf("出队: %d \n", pop(que));

    push(que, 8);
    printf("出队: %d \n", pop(que));
    printf("出队: %d \n", pop(que));
    push(que, 14);
    push(que, 15);

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", que->data[i]);
    }

    printf("\n");

    delArrayQueue(que);
    return 0;
}
```





### 内核链表



```c
#include <stdio.h>
#include <stdlib.h>
#include "kernel_list.h"

typedef struct
{
    int data;
    struct list_head list;
} Node;

typedef struct
{
    int size;
    struct list_head *head;         // 内核链表头结点指针
    struct list_head *front, *rear; // 队列队首队尾小结构体指针
} KernelListQueue;

KernelListQueue *newKernelListQueue()
{
    // 创建内核链表队列结构体
    KernelListQueue *q = malloc(sizeof(KernelListQueue));
    if (q == NULL)
    {
        perror("newKernelListQueue failed !\n");
        return NULL;
    }
    // 创建内核链表头结点
    Node *n = malloc(sizeof(Node));
    if (n == NULL)
    {
        perror("newKernelListQueue failed !\n");
        free(q);
        return NULL;
    }

    // 初始化内核链表节点
    INIT_LIST_HEAD(&n->list);

    q->head = &n->list;
    q->front = NULL;
    q->rear = NULL;
    q->size = 0;

    return q;
}

int isEmpty(KernelListQueue *q)
{
    return q->size == 0;
}

// 队列先进先出 尾插头删

void push(KernelListQueue *q, int data)
{
    // 创建内核链表节点
    Node *n = malloc(sizeof(Node));
    if (n == NULL)
    {
        perror("push malloc failed!\n");
        return;
    }

    n->data = data;
    // 内核链表提供的尾插
    list_add_tail(&n->list, q->head);
    // 更新队尾
    q->rear = &n->list;
    // 若队列为空,更新队首
    if (isEmpty(q))
    {
        q->front = &(n->list);
    }
    q->size++;
}

int peek(KernelListQueue *q)
{
    if (isEmpty(q))
    {
        printf("队列为空!\n");
        return -1;
    }

    Node *n = list_entry(q->front, Node, list);

    return n->data;
}

int pop(KernelListQueue *q)
{
    if (isEmpty(q))
    {
        printf("队列为空无法出队 \n");
        return -1;
    }

    int res = peek(q);
    // 头删,拿到要删除的那个小结构体对应的大结构体
    Node *n = list_entry(q->front, Node, list);

    q->front = q->front->next;
    // 调用内核链表的删除节点方法
    list_del(&n->list);
    free(n);
    q->size--;

    return res;
}

void delKernelListQueue(KernelListQueue *q)
{
    while (!isEmpty(q))
    {
        pop(q);
    }

    Node *head = list_entry(q->head, Node, list);
    free(head);
    free(q);
}

int main(int argc, char const *argv[])
{
    KernelListQueue *que = newKernelListQueue();

    push(que, 2);
    push(que, 3);

    printf("pop: %d \n", pop(que));
    push(que, 13);

    struct list_head *p = que->front;

    while (p != que->head) {
        Node *n = list_entry(p, Node, list);
        printf("%d ", n->data);
        if (p == que->rear) {
            printf("结束");
        }
        p = p->next;
    }

    printf("\n");

    delKernelListQueue(que);
    return 0;
}
```

